// Code generated by protoc-gen-go. DO NOT EDIT.
// source: echo-tars.proto

package tars

import (
	context "context"
	fmt "fmt"
	tars "github.com/TarsCloud/TarsGo/tars"
	model "github.com/TarsCloud/TarsGo/tars/model"
	requestf "github.com/TarsCloud/TarsGo/tars/protocol/res/requestf"
	current "github.com/TarsCloud/TarsGo/tars/util/current"
	tools "github.com/TarsCloud/TarsGo/tars/util/tools"
	proto "github.com/golang/protobuf/proto"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type Request struct {
	Action               string   `protobuf:"bytes,1,opt,name=Action,proto3" json:"Action,omitempty"`
	Field1               string   `protobuf:"bytes,2,opt,name=field1,proto3" json:"field1,omitempty"`
	Field2               string   `protobuf:"bytes,3,opt,name=field2,proto3" json:"field2,omitempty"`
	Field3               string   `protobuf:"bytes,4,opt,name=field3,proto3" json:"field3,omitempty"`
	Field4               string   `protobuf:"bytes,5,opt,name=field4,proto3" json:"field4,omitempty"`
	Field5               string   `protobuf:"bytes,6,opt,name=field5,proto3" json:"field5,omitempty"`
	Field6               string   `protobuf:"bytes,7,opt,name=field6,proto3" json:"field6,omitempty"`
	Field7               string   `protobuf:"bytes,8,opt,name=field7,proto3" json:"field7,omitempty"`
	Field8               string   `protobuf:"bytes,9,opt,name=field8,proto3" json:"field8,omitempty"`
	Field9               string   `protobuf:"bytes,10,opt,name=field9,proto3" json:"field9,omitempty"`
	Field10              string   `protobuf:"bytes,11,opt,name=field10,proto3" json:"field10,omitempty"`
	Time                 int64    `protobuf:"varint,12,opt,name=time,proto3" json:"time,omitempty"`
	Length               int64    `protobuf:"varint,13,opt,name=length,proto3" json:"length,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Request) Reset()         { *m = Request{} }
func (m *Request) String() string { return proto.CompactTextString(m) }
func (*Request) ProtoMessage()    {}
func (*Request) Descriptor() ([]byte, []int) {
	return fileDescriptor_71db2e9888f09946, []int{0}
}

func (m *Request) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Request.Unmarshal(m, b)
}
func (m *Request) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Request.Marshal(b, m, deterministic)
}
func (m *Request) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Request.Merge(m, src)
}
func (m *Request) XXX_Size() int {
	return xxx_messageInfo_Request.Size(m)
}
func (m *Request) XXX_DiscardUnknown() {
	xxx_messageInfo_Request.DiscardUnknown(m)
}

var xxx_messageInfo_Request proto.InternalMessageInfo

func (m *Request) GetAction() string {
	if m != nil {
		return m.Action
	}
	return ""
}

func (m *Request) GetField1() string {
	if m != nil {
		return m.Field1
	}
	return ""
}

func (m *Request) GetField2() string {
	if m != nil {
		return m.Field2
	}
	return ""
}

func (m *Request) GetField3() string {
	if m != nil {
		return m.Field3
	}
	return ""
}

func (m *Request) GetField4() string {
	if m != nil {
		return m.Field4
	}
	return ""
}

func (m *Request) GetField5() string {
	if m != nil {
		return m.Field5
	}
	return ""
}

func (m *Request) GetField6() string {
	if m != nil {
		return m.Field6
	}
	return ""
}

func (m *Request) GetField7() string {
	if m != nil {
		return m.Field7
	}
	return ""
}

func (m *Request) GetField8() string {
	if m != nil {
		return m.Field8
	}
	return ""
}

func (m *Request) GetField9() string {
	if m != nil {
		return m.Field9
	}
	return ""
}

func (m *Request) GetField10() string {
	if m != nil {
		return m.Field10
	}
	return ""
}

func (m *Request) GetTime() int64 {
	if m != nil {
		return m.Time
	}
	return 0
}

func (m *Request) GetLength() int64 {
	if m != nil {
		return m.Length
	}
	return 0
}

type Response struct {
	Action               string   `protobuf:"bytes,1,opt,name=Action,proto3" json:"Action,omitempty"`
	Msg                  string   `protobuf:"bytes,2,opt,name=msg,proto3" json:"msg,omitempty"`
	IsEnd                bool     `protobuf:"varint,3,opt,name=isEnd,proto3" json:"isEnd,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Response) Reset()         { *m = Response{} }
func (m *Response) String() string { return proto.CompactTextString(m) }
func (*Response) ProtoMessage()    {}
func (*Response) Descriptor() ([]byte, []int) {
	return fileDescriptor_71db2e9888f09946, []int{1}
}

func (m *Response) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Response.Unmarshal(m, b)
}
func (m *Response) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Response.Marshal(b, m, deterministic)
}
func (m *Response) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Response.Merge(m, src)
}
func (m *Response) XXX_Size() int {
	return xxx_messageInfo_Response.Size(m)
}
func (m *Response) XXX_DiscardUnknown() {
	xxx_messageInfo_Response.DiscardUnknown(m)
}

var xxx_messageInfo_Response proto.InternalMessageInfo

func (m *Response) GetAction() string {
	if m != nil {
		return m.Action
	}
	return ""
}

func (m *Response) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func (m *Response) GetIsEnd() bool {
	if m != nil {
		return m.IsEnd
	}
	return false
}

func init() {
	proto.RegisterType((*Request)(nil), "protobuf.Request")
	proto.RegisterType((*Response)(nil), "protobuf.Response")
}

func init() {
	proto.RegisterFile("echo-tars.proto", fileDescriptor_71db2e9888f09946)
}

var fileDescriptor_71db2e9888f09946 = []byte{
	// 326 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0xd2, 0xcd, 0x4e, 0xc2, 0x40,
	0x10, 0x07, 0x70, 0x0b, 0x05, 0xca, 0xaa, 0x51, 0x37, 0xc6, 0x4c, 0x3c, 0x11, 0x4e, 0x5c, 0x68,
	0x91, 0xef, 0xc6, 0x93, 0x26, 0x5c, 0x3c, 0x16, 0x4f, 0xde, 0xba, 0x65, 0xa0, 0x0d, 0xec, 0x2e,
	0xb6, 0x4b, 0x82, 0xbe, 0x9c, 0xaf, 0x66, 0xfa, 0xb5, 0xd9, 0x8b, 0x89, 0xa7, 0xce, 0xff, 0xd7,
	0x74, 0x9a, 0x9d, 0x59, 0x72, 0x83, 0x51, 0x2c, 0x87, 0x2a, 0x4c, 0x33, 0xf7, 0x98, 0x4a, 0x25,
	0xa9, 0x53, 0x3c, 0xd8, 0x69, 0xdb, 0xff, 0x69, 0x90, 0x4e, 0x80, 0x9f, 0x27, 0xcc, 0x14, 0x7d,
	0x20, 0xed, 0x97, 0x48, 0x25, 0x52, 0x80, 0xd5, 0xb3, 0x06, 0xdd, 0xa0, 0x4a, 0xb9, 0x6f, 0x13,
	0x3c, 0x6c, 0x9e, 0xa0, 0x51, 0x7a, 0x99, 0xb4, 0x8f, 0xa1, 0x69, 0xf8, 0x58, 0xfb, 0x04, 0x6c,
	0xc3, 0x27, 0xda, 0xa7, 0xd0, 0x32, 0x7c, 0xaa, 0x7d, 0x06, 0x6d, 0xc3, 0x67, 0xda, 0xe7, 0xd0,
	0x31, 0x7c, 0xae, 0x7d, 0x01, 0x8e, 0xe1, 0x0b, 0xed, 0x4b, 0xe8, 0x1a, 0xbe, 0xd4, 0xee, 0x03,
	0x31, 0xdc, 0xa7, 0x40, 0x3a, 0xe5, 0x49, 0x46, 0x70, 0x59, 0xbc, 0xa8, 0x23, 0xa5, 0xc4, 0x56,
	0x09, 0x47, 0xb8, 0xea, 0x59, 0x83, 0x66, 0x50, 0xd4, 0x79, 0x97, 0x03, 0x8a, 0x9d, 0x8a, 0xe1,
	0xba, 0xd0, 0x2a, 0xf5, 0xdf, 0x88, 0x13, 0x60, 0x76, 0x94, 0x22, 0xc3, 0x3f, 0x27, 0x78, 0x4b,
	0x9a, 0x3c, 0xdb, 0x55, 0xe3, 0xcb, 0x4b, 0x7a, 0x4f, 0x5a, 0x49, 0xb6, 0x12, 0x9b, 0x62, 0x74,
	0x4e, 0x50, 0x86, 0x71, 0x4a, 0xec, 0x55, 0x14, 0x4b, 0xea, 0x11, 0x7b, 0x8d, 0x62, 0x43, 0xef,
	0xdc, 0x7a, 0x51, 0x6e, 0xb5, 0xa4, 0x47, 0x6a, 0x52, 0xf9, 0xdb, 0xfe, 0x05, 0xf5, 0x09, 0x59,
	0xab, 0x14, 0x43, 0xfe, 0x9e, 0x2f, 0xf2, 0xbf, 0x9f, 0x0d, 0xac, 0x91, 0xf5, 0xfa, 0xfc, 0xe1,
	0xef, 0x12, 0x15, 0x9f, 0x98, 0x1b, 0x49, 0xee, 0x31, 0xc6, 0x30, 0x4c, 0xcf, 0x5f, 0xdf, 0xde,
	0x3e, 0x51, 0x78, 0x1e, 0x32, 0x14, 0x51, 0xcc, 0xc3, 0x74, 0xef, 0x45, 0x92, 0x73, 0x29, 0xbc,
	0xba, 0x8d, 0x97, 0x5f, 0x27, 0xd6, 0x2e, 0xe2, 0xe4, 0x37, 0x00, 0x00, 0xff, 0xff, 0x7a, 0x6b,
	0x49, 0x57, 0x62, 0x02, 0x00, 0x00,
}

// This following code was generated by tarsrpc
// Gernerated from echo-tars.proto
type Echo struct {
	servant model.Servant
}

// SetServant is required by the servant interface.
func (obj *Echo) SetServant(servant model.Servant) {
	obj.servant = servant
}

// AddServant is required by the servant interface
func (obj *Echo) AddServant(imp PBEchoServant, objStr string) {
	tars.AddServant(obj, imp, objStr)
}

// AddServantWithContext adds servant  for the service with context
func (obj *Echo) AddServantWithContext(imp PBEchoServantWithContext, objStr string) {
	tars.AddServantWithContext(obj, imp, objStr)
}

// TarsSetTimeout is required by the servant interface. t is the timeout in ms.
func (obj *Echo) TarsSetTimeout(t int) {
	obj.servant.TarsSetTimeout(t)
}

// TarsSetProtocol is required by the servant interface. t is the protocol.
func (obj *Echo) TarsSetProtocol(p model.Protocol) {
	obj.servant.TarsSetProtocol(p)
}

type PBEchoServant interface {
	Send(input Request) (output Response, err error)
	StreamTest(input Request) (output Response, err error)
}

type PBEchoServantWithContext interface {
	Send(ctx context.Context, input Request) (output Response, err error)
	StreamTest(ctx context.Context, input Request) (output Response, err error)
}

// Dispatch is used to call the user implement of the defined method.
func (obj *Echo) Dispatch(ctx context.Context, val interface{}, req *requestf.RequestPacket, resp *requestf.ResponsePacket, withContext bool) (err error) {
	input := tools.Int8ToByte(req.SBuffer)
	var output []byte
	funcName := req.SFuncName
	switch funcName {

	case "Send":
		inputDefine := Request{}
		if err = proto.Unmarshal(input, &inputDefine); err != nil {
			return err
		}
		var res Response
		if !withContext {
			imp := val.(PBEchoServant)
			res, err = imp.Send(inputDefine)
			if err != nil {
				return err
			}
		} else {
			imp := val.(PBEchoServantWithContext)
			res, err = imp.Send(ctx, inputDefine)
			if err != nil {
				return err
			}
		}
		output, err = proto.Marshal(&res)
		if err != nil {
			return err
		}

	case "StreamTest":
		inputDefine := Request{}
		if err = proto.Unmarshal(input, &inputDefine); err != nil {
			return err
		}
		var res Response
		if !withContext {
			imp := val.(PBEchoServant)
			res, err = imp.StreamTest(inputDefine)
			if err != nil {
				return err
			}
		} else {
			imp := val.(PBEchoServantWithContext)
			res, err = imp.StreamTest(ctx, inputDefine)
			if err != nil {
				return err
			}
		}
		output, err = proto.Marshal(&res)
		if err != nil {
			return err
		}

	default:
		return fmt.Errorf("func mismatch")
	}
	var statusMap map[string]string
	if status, ok := current.GetResponseStatus(ctx); ok && status != nil {
		statusMap = status
	}
	var contextMap map[string]string
	if ctx, ok := current.GetResponseContext(ctx); ok && ctx != nil {
		contextMap = ctx
	}
	*resp = requestf.ResponsePacket{
		IVersion:     1,
		CPacketType:  0,
		IRequestId:   req.IRequestId,
		IMessageType: 0,
		IRet:         0,
		SBuffer:      tools.ByteToInt8(output),
		Status:       statusMap,
		SResultDesc:  "",
		Context:      contextMap,
	}
	return nil
}

// Send is client rpc method as defined
func (obj *Echo) Send(input Request, opts ...map[string]string) (output Response, err error) {
	ctx := context.Background()
	return obj.SendWithContext(ctx, input, opts...)
}

// SendWithContext is client rpc method as defined
func (obj *Echo) SendWithContext(ctx context.Context, input Request, opts ...map[string]string) (output Response, err error) {
	var inputMarshal []byte
	inputMarshal, err = proto.Marshal(&input)
	if err != nil {
		return output, err
	}

	var statusMap map[string]string
	var contextMap map[string]string
	if len(opts) == 1 {
		contextMap = opts[0]
	} else if len(opts) == 2 {
		contextMap = opts[0]
		statusMap = opts[1]
	}

	resp := new(requestf.ResponsePacket)
	err = obj.servant.TarsInvoke(ctx, 0, "Send", inputMarshal, statusMap, contextMap, resp)
	if err != nil {
		return output, err
	}
	if err = proto.Unmarshal(tools.Int8ToByte(resp.SBuffer), &output); err != nil {
		return output, err
	}

	if len(opts) == 1 {
		for k := range contextMap {
			delete(contextMap, k)
		}
		for k, v := range resp.Context {
			contextMap[k] = v
		}
	} else if len(opts) == 2 {
		for k := range contextMap {
			delete(contextMap, k)
		}
		for k, v := range resp.Context {
			contextMap[k] = v
		}
		for k := range statusMap {
			delete(statusMap, k)
		}
		for k, v := range resp.Status {
			statusMap[k] = v
		}
	}
	return output, nil
}

// StreamTest is client rpc method as defined
func (obj *Echo) StreamTest(input Request, opts ...map[string]string) (output Response, err error) {
	ctx := context.Background()
	return obj.StreamTestWithContext(ctx, input, opts...)
}

// StreamTestWithContext is client rpc method as defined
func (obj *Echo) StreamTestWithContext(ctx context.Context, input Request, opts ...map[string]string) (output Response, err error) {
	var inputMarshal []byte
	inputMarshal, err = proto.Marshal(&input)
	if err != nil {
		return output, err
	}

	var statusMap map[string]string
	var contextMap map[string]string
	if len(opts) == 1 {
		contextMap = opts[0]
	} else if len(opts) == 2 {
		contextMap = opts[0]
		statusMap = opts[1]
	}

	resp := new(requestf.ResponsePacket)
	err = obj.servant.TarsInvoke(ctx, 0, "StreamTest", inputMarshal, statusMap, contextMap, resp)
	if err != nil {
		return output, err
	}
	if err = proto.Unmarshal(tools.Int8ToByte(resp.SBuffer), &output); err != nil {
		return output, err
	}

	if len(opts) == 1 {
		for k := range contextMap {
			delete(contextMap, k)
		}
		for k, v := range resp.Context {
			contextMap[k] = v
		}
	} else if len(opts) == 2 {
		for k := range contextMap {
			delete(contextMap, k)
		}
		for k, v := range resp.Context {
			contextMap[k] = v
		}
		for k := range statusMap {
			delete(statusMap, k)
		}
		for k, v := range resp.Status {
			statusMap[k] = v
		}
	}
	return output, nil
}
